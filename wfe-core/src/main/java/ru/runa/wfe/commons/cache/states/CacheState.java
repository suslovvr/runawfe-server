package ru.runa.wfe.commons.cache.states;

import javax.transaction.Transaction;
import lombok.NonNull;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import ru.runa.wfe.commons.cache.CacheImplementation;
import ru.runa.wfe.commons.cache.ChangedObjectParameter;
import ru.runa.wfe.commons.cache.sm.SMCacheFactory;
import ru.runa.wfe.commons.cache.sm.CacheStateMachine;

/**
 * Interface for every state of cache lifetime state machine.
 */
public abstract class CacheState<CacheImpl extends CacheImplementation> {
    protected final Log log = LogFactory.getLog(getClass());
    protected final CacheStateMachine<CacheImpl> owner;

    public CacheState(@NonNull CacheStateMachine<CacheImpl> owner) {
        this.owner = owner;
    }

    protected final CacheStateMachine<CacheImpl> getStateMachine() {
        return owner;
    }

    protected final SMCacheFactory<CacheImpl> getCacheFactory() {
        return owner.getCacheFactory();
    }

    protected final CacheStateFactory<CacheImpl> getStateFactory() {
        return owner.getStateFactory();
    }


    /**
     * Check if dirty transactions exists for cache.
     *
     * @return Return true, if dirty transaction exists and false otherwise.
     */
    public boolean isDirtyTransactionExists() {
        return false;
    }

    /**
     * Check if transaction is dirty for cache.
     *
     * @param transaction
     *            Transaction to check.
     * @return Return true, if transaction is dirty and false otherwise.
     */
    public boolean isDirtyTransaction(Transaction transaction) {
        return false;
    }

    /**
     * Fast attempt to get cache. State may return cache only if it already created. No building is allowed.
     *
     * @param transaction
     *            Transaction, which requested cache.
     *
     * @return Returns already builded cache or null, if no cache is builded yet.
     */
    public abstract CacheImpl getCacheQuickNoBuild(Transaction transaction);

    /**
     * Called to get cache. Cache must be created in all case.
     *
     * @param transaction
     *            Transaction, which requested cache.
     * @return Returns next state and cache. Next state may be null if no state change is required.
     */
    public abstract StateCommandResultWithCache<CacheImpl> getCache(Transaction transaction);

    /**
     * Called to get cache. Must returns null (or already created cache) if cache is locked (has dirty transactions): no cache creation is allowed
     * (return as fast as possible). If cache is not locked, then creates cache.
     *
     * @param transaction
     *            Transaction, which requested cache.
     * @return Returns next state and cache. Next state may be null if no state change is required. Cache may be null, if cache is locked.
     */
    public abstract StateCommandResultWithCache<CacheImpl> getCacheIfNotLocked(Transaction transaction);

    /**
     * Notification about changed object. This method MUST return new state; if new state not created then we have a rise condition: starting
     * initialize process after not completed changing transaction.
     *
     * @param transaction
     *            Transaction, which change persistent object.
     * @param changedObject
     *            Changed object description.
     * @return Returns next state is mandatory.
     */
    public abstract StateCommandResult<CacheImpl> onChange(Transaction transaction, ChangedObjectParameter changedObject);

    /**
     * Notifies about prepare to transaction completion.
     *
     * @param transaction
     *            Transaction, which will be completed.
     * @return Returns next state. Next state may be null if no state change is required.
     */
    public abstract StateCommandResult<CacheImpl> onBeforeTransactionComplete(Transaction transaction);

    /**
     * Notifies cache about transaction completion. This method MUST return new state. if new state not created then we have a rise condition:
     * changing transaction may switch to new state, where current transaction is not marked as completed.
     *
     * @param transaction
     *            Completed transaction (committed or rollbacked).
     * @return Returns next state and all dirty transaction reset flag. Flag equals true, if no dirty transaction left and false otherwise.
     */
    public abstract StateCommandResultWithData<CacheImpl, Boolean> onAfterTransactionComplete(Transaction transaction);

    /**
     * Commits (accept) initialized cache.
     *
     * @param cache
     *            Initialized cache to commit (accept).
     * @return Returns next state. Next state may be null if no state change is required.
     */
    public StateCommandResult<CacheImpl> commitCache(CacheImpl cache) {
        log.error("commitCache must not be called on " + this);
        return StateCommandResult.createNoStateSwitch();
    }

    /**
     * Discard this state. All lazy work must not be done - this state and caches from it will not be used.
     */
    public void discard() {
    }

    /**
     * Accept this state. Called then state is accepted by state machine. Delayed initialization may be started.
     */
    public void accept() {
    }

    /**
     * Called to drop cache instance. It must be changed to empty.
     */
    public StateCommandResult<CacheImpl> dropCache() {
        return StateCommandResult.create(getStateFactory().createEmptyState(null));
    }
}
