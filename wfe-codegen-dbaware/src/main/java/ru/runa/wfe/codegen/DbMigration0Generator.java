package ru.runa.wfe.codegen;

import java.io.File;
import java.io.FileWriter;
import lombok.val;
import lombok.var;
import ru.runa.wfe.codegen.DbStructureAnalyzer.Structure;

class DbMigration0Generator {

    static void generate(Structure st, File f) throws Exception {
        val w = new FileWriter(f);
        w.write("//\n" +
                "// ATTENTION!!! This file is auto-generated by wfe-codegen-dbaware subproject. See README.txt there.\n" +
                "//\n" +
                "package ru.runa.wfe.commons.dbmigration;\n" +
                "\n");
        if (!st.migrations.isEmpty() || st.version != null) {
            w.write("import java.sql.Connection;\n");
        }
        if (!st.migrations.isEmpty()) {
            w.write("import java.sql.PreparedStatement;\n");
        }
        if (st.version != null) {
            w.write("import java.sql.Statement;\n");
        }
        if (!st.migrations.isEmpty()) {
            w.write("import java.sql.Timestamp;\n");
        }
        w.write("\n" +
                "public class DbMigration0 extends DbMigration {\n" +
                "\n" +
                "    @Override\n" +
                "    @SuppressWarnings(\"ConstantConditions\")\n" +
                "    protected void executeDDLBefore() {\n" +
                "        executeUpdates(");


        var firstSequence = true;
        for (val s : st.sequenceNames) {
            if (firstSequence) {
                firstSequence = false;
                w.write("\n");
            } else {
                w.write(",\n");
            }
            w.write("                getDDLCreateSequence(\"" + s + "\")");
        }


        var firstTable = true;
        for (val t : st.tables) {
            if (firstTable) {
                firstTable = false;
                w.write(st.sequenceNames.isEmpty() ? "\n" : ",\n\n");
            } else {
                w.write(",\n");
            }
            w.write("                getDDLCreateTable(\"" + t.name + "\", list(");
            var firstColumn = true;
            for (val c : t.columns) {
                if (firstColumn) {
                    firstColumn = false;
                    w.write("\n");
                } else {
                    w.write(",\n");
                }
                w.write("                        new ");

                val quotedName = "\"" + c.name + "\"";
                // No need for "not null" for PK column:
                switch (c.type) {
                    case BIGINT:
                        w.write("BigintColumnDef(" + quotedName + ")");
                        break;
                    case BLOB:
                        w.write("BlobColumnDef(" + quotedName + ")");
                        break;
                    case BOOLEAN:
                        w.write("BooleanColumnDef(" + quotedName + ")");
                        break;
                    case CHAR:
                        w.write("CharColumnDef(" + quotedName + ", " + c.typeLength + ")");
                        break;
                    case DOUBLE:
                        w.write("DoubleColumnDef(" + quotedName + ")");
                        break;
                    case INT:
                        w.write("IntColumnDef(" + quotedName + ")");
                        break;
                    case TIMESTAMP:
                        w.write("TimestampColumnDef(" + quotedName + ")");
                        break;
                    case VARCHAR:
                        w.write("VarcharColumnDef(" + quotedName + ", " + c.typeLength + ")");
                        break;
                    default:
                        throw new Exception("Internal error: unhandled column type " + c.type);
                }
                if (c.isPrimaryKey) {
                    if (st.sequenceNames.contains("seq_" + t.name)) {
                        w.write(".primaryKey()");
                    } else {
                        w.write(".primaryKeyNoAutoInc()");
                    }
                } else if (c.isNotNull) {
                    w.write(".notNull()");
                }
            }
            w.write("\n" +
                    "                ))");
        }


        // Creating indexes before UK and FK, to avoid automatic index creation by SQL server.
        var firstIndex = true;
        for (val i : st.indexes) {
            if (firstIndex) {
                firstIndex = false;
                w.write(",\n\n");
            } else {
                w.write(",\n");
            }
            w.write("                getDDLCreateIndex(\"" + i.table.name + "\", \"" + i.name + "\"");
            for (val c : i.columns) {
                w.write(", \"" + c.name + "\"");
            }
            w.write(")");
        }


        var firstUk = true;
        for (val uk : st.uniqueKeys) {
            if (firstUk) {
                firstUk = false;
                w.write(",\n\n");
            } else {
                w.write(",\n");
            }
            w.write("                getDDLCreateUniqueKey(\"" + uk.table.name + "\", \"" + uk.constraintName + "\"");
            for (val c : uk.columns) {
                w.write(", \"" + c.name + "\"");
            }
            w.write(")");
        }


        var firstFk = true;
        for (val fk : st.foreignKeys) {
            if (firstFk) {
                firstFk = false;
                w.write(",\n\n");
            } else {
                w.write(",\n");
            }
            w.write("                getDDLCreateForeignKey(\"" + fk.table.name + "\", \"" + fk.constraintName + "\", \"" + fk.column.name +
                    "\", \"" + fk.refTable.name + "\", \"" + fk.refColumn.name + "\")");
        }


        w.write("\n        );\n" +
                "    }\n");


        if (!st.migrations.isEmpty() || st.version != null) {
            w.write("\n" +
                    "    @Override\n" +
                    "    public void executeDML(Connection conn) throws Exception {\n");
            if (!st.migrations.isEmpty()) {
                w.write("        try (PreparedStatement stmt = conn.prepareStatement(\"insert into db_migration(name, when_started, when_finished) values(?, ?, ?)\")) {\n");
                for (val m : st.migrations) {
                    // TODO I wonder if timezone will interfere so each run we'll get more and more shifted time.
                    w.write("            insertMigration(stmt, \"" + m.name + "\", " + m.whenStarted.getTime() + "L, " +
                            (m.whenFinished == null ? "null" : m.whenFinished.getTime() + "L") + ");\n");
                }
                w.write("        }\n");
            }
            if (st.version != null) {
                w.write("        try (Statement stmt = conn.createStatement()) {\n" +
                        "            stmt.executeUpdate(\"insert into wfe_constants (\" + insertPkColumn() + \"name, value) values (\" +\n" +
                        "                    insertPkNextVal(\"wfe_constants\") + \"'ru.runa.database_version', " + st.version + ")\");\n" +
                        "        }\n");
            }
            w.write("    }\n");
            if (!st.migrations.isEmpty()) {
                w.write("\n" +
                        "    private void insertMigration(PreparedStatement stmt, String name, long whenStarted, Long whenFinished) throws Exception {\n" +
                        "        stmt.setString(1, name);\n" +
                        "        stmt.setTimestamp(2, new Timestamp(whenStarted));\n" +
                        "        stmt.setTimestamp(3, whenFinished == null ? null : new Timestamp(whenFinished));\n" +
                        "        stmt.executeUpdate();\n" +
                        "    }\n");
            }
        }
        w.write("}\n");
        w.close();
    }
}
